#Requires AutoHotkey v2.0
Class WindowWrapperClass {
    __New(WinTitle, Boolean_AutoFindThisCritiera?){
        if IsSet(Boolean_AutoFindThisCritiera)
            this.AutoFindThisCriteria := WinTitle
        this.Hwnd := WinExist(WinTitle)
    }
    AutoFindThisCriteria := Unset
    Hwnd := ""
    Title{
        Get=> WinGetTitle(this.Hwnd)
        Set=> WinSetTitle(Value, this.Hwnd)
    }
    X{
        Get=> (WinGetPos(&GetValue,,,, this.Hwnd), GetValue)
        Set=> (WinMove(Value,,,, this.Hwnd))
    }
    Y{
        Get=> (WinGetPos(, &GetValue,,, this.Hwnd), GetValue)
        Set=> (WinMove(,Value,,, this.Hwnd))
    }
    W{
        Get=> (WinGetPos(,, &GetValue,, this.Hwnd), GetValue)
        Set=> (WinMove(,,Value,, this.Hwnd))
    }
    H{
        Get=> (WinGetPos(,,, &GetValue, this.Hwnd), GetValue)
        Set=> (WinMove(,,,Value, this.Hwnd))
    }
    X2{
        Get=> (WinGetPos(&x,,&w,, this.Hwnd), X + W)
        Set=> WinMove(Value-this.W,,,, this.Hwnd)
    }
    Y2{
        Get=> (WinGetPos(,&y,,,&h this.Hwnd), Y + H)
        Set=> WinMove(,Value-this.H,,, this.Hwnd)
    }
    isAlwaysOnTop{
        Get=> WinGetExStyle(this.Hwnd) & 0x8 ? True : False
        Set=> WinSetAlwaysOnTop(Value, this.Hwnd)
    }
    isExist=> (WinExist(this.Hwnd) || this.HasOwnProp("AutoFindThisCriteria") && (this.Hwnd := WinExist(this.AutoFindThisCriteria)))
    isHidden=> (DetectHiddenWindows(false), WinExist(this.Hwnd) && !WinExist("ahk_id" this.Hwnd))
    isMinimized=> (WinGetMinMax(this.Hwnd)=-1)
    isMaximized=> (WinGetMinMax(this.Hwnd)=1)
    isNotMinMax=> (WinGetMinMax(this.Hwnd)=0)
    isMouseOver=> (MouseGetPos(,,&mWin), mWin=this.Hwnd)
    CheckMouseOverClientRegion(x1, y1, x2, y2){
        CoordMode("Mouse", "Client")
        MouseGetPos(&mx, &my, &mwin)
        Return (mwin = this.Hwnd and WindowWrapperClass.Range(mx, x1, x2) and WindowWrapperClass.Range(my, y1, y2))
    }
    ControlSendKeys(KeyNames*){
        StringControlSendDown := ""
        StringControlSendUp := ""
        Loop KeyNames.Length {
            StringControlSendDown .= "{" KeyNames[A_Index] " Down}"
            StringControlSendUp .= "{" KeyNames[-A_Index] " Up}"
        }
        ControlSend(StringControlSendDown,, this.Hwnd)
        Sleep 25
        ControlSend(StringControlSendUp,, this.Hwnd)
    }
    ControlClickPos(x, y){
        ControlClick(Format("x{1} y{2}", x, y), this.Hwnd)
    }
    CheckisWindowSize(x, y, w, h){
        this.SetMinMaxState(0)
        WinGetPos(&wx, &wy, &ww, &wh, this.Hwnd)
        Return(x=wx & y=wy & w=ww & h=wh)
    }
    SetMinMaxState(State){
        Switch State {
            Case -1: (!(this.isMinimized) && WinMinimize(this.Hwnd))
            Case 0: (!(this.isNotMinMax) && WinRestore(this.Hwnd))
            Case 1: (!(this.isMaximized) && WinMaximize(this.Hwnd))
        }
    }
    SetOnTop(){
        Critical(true)
        PriorState := this.isAlwaysOnTop
        this.isAlwaysOnTop := true
        this.isAlwaysOnTop := PriorState
    }
    WinMove(x?, y?, w?, h?){
        this.SetMinMaxState(0)
        If !this.CheckisWindowSize(x, y, w, h)
            WinMove(x?, y?, w?, h?, this.Hwnd)
    }
    BatchOptions(ObjectWithPropValues){
        For PropName, Value in ObjectWithPropValues.HasOwnProp()
            this.%PropName% := Value
    }
    Static Range(Value, Min, Max){
        Return (Min < Value and Value < Max)
    }
}
