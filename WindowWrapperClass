Class WindowWrapperClass {
    __New(WinTitle, Boolean_AutoFindThisCritiera?){
        if IsSet(Boolean_AutoFindThisCritiera)
            this.AutoFindThisCriteria := WinTitle
        this.Hwnd := WinExist(WinTitle)
        OnExit((*)=>this.isExist && this.isHidden:=false)
    }
    AutoFindThisCriteria := Unset
    Hwnd := ""
    Title{
        Get=> WinGetTitle(this.Hwnd)
        Set=> WinSetTitle(Value, this.Hwnd)
    }
    X{
        Get=> (WinGetPos(&GetValue,,,, this.Hwnd), GetValue)
        Set=> (WinMove(Value,,,, this.Hwnd))
    }
    Y{
        Get=> (WinGetPos(, &GetValue,,, this.Hwnd), GetValue)
        Set=> (WinMove(,Value,,, this.Hwnd))
    }
    W{
        Get=> (WinGetPos(,, &GetValue,, this.Hwnd), GetValue)
        Set=> (WinMove(,,Value,, this.Hwnd))
    }
    H{
        Get=> (WinGetPos(,,, &GetValue, this.Hwnd), GetValue)
        Set=> (WinMove(,,,Value, this.Hwnd))
    }
    X2{
        Get=> (WinGetPos(&x,,&w,, this.Hwnd), X + W)
        Set=> WinMove(Value-this.W,,,, this.Hwnd)
    }
    Y2{
        Get=> (WinGetPos(,&y,,,&h this.Hwnd), Y + H)
        Set=> WinMove(,Value-this.H,,, this.Hwnd)
    }
    isAlwaysOnTop{
        Get=> WinGetExStyle(this.Hwnd) & 0x8 ? True : False
        Set=> WinSetAlwaysOnTop(Value, this.Hwnd)
    }
    isExist=> (WinExist(this.Hwnd) || this.HasOwnProp("AutoFindThisCriteria") && (this.Hwnd := WinExist(this.AutoFindThisCriteria)))
    isHidden{
        Get=> (DetectHiddenWindows(false), WinExist(this.Hwnd) && !WinExist("ahk_id" this.Hwnd))
        Set=> Value=true && !this.isHidden && WinHide(this.Hwnd) or Value=false && this.isHidden && WinShow(this.Hwnd)
    }
    isMinimized{
        Get=> (WinGetMinMax(this.Hwnd)=-1)
        Set=> (Value ? WinMinimize(this.Hwnd) : WinRestore(this.Hwnd))
    }
    isMaximized{
        Get=> (WinGetMinMax(this.Hwnd)=1)
        Set=> (Value ? WinMaximize(this.Hwnd) : WinRestore(this.Hwnd))
    }
    isNotMinMax{
        Get=> (WinGetMinMax(this.Hwnd)=0)
        Set=> (Value && WinRestore(this.Hwnd))
    }
    isMouseOver=> (MouseGetPos(,,&mWin), mWin=this.Hwnd)
    isActive{
        Get=> WinActive(this.Hwnd)
        Set=> Value && WinActivate(this.Hwnd)
    }

    Fn_ControlFocus(){
        ControlFocus(this.Hwnd)
    }

    Fn_isMouseOverClientRegion(x1, y1, x2, y2){
        CoordMode("Mouse", "Client")
        MouseGetPos(&mx, &my, &mwin)
        Return (mwin = this.Hwnd and WindowWrapperClass.Fn_Range(mx, x1, x2) and WindowWrapperClass.Fn_Range(my, y1, y2))
    }
    Fn_ControlSendKeys(Control, Space_Separated_KeyNames){
        StringControlSendDown := ""
        StringControlSendUp := ""
        KeyNamesArr := StrSplit(Space_Separated_KeyNames, " ")
        Loop KeyNamesArr.Length {
            If KeyDown := KeyNamesArr[A_Index]
                StringControlSendDown .= "{" KeyDown " Down}"
            If KeyUp := KeyNamesArr[-A_Index]
                StringControlSendUp .= "{" KeyUp " Up}"
        }
        If isPriorWindowExist := WinExist("A"){
            PriorActiveWindow := WinGetID("A")
            PriorFocusedControl := ControlGetFocus("A")
        }
        If !WinActive(this.Hwnd)
            ControlFocus(this.Hwnd)
        ReleasedKeysArr := WindowWrapperClass.Fn_ReleaseModifiers()
        ControlSend(StringControlSendDown,Control?, this.Hwnd)
        WindowWrapperClass.Fn_RepressModifiers(ReleasedKeysArr)
        Sleep 30
        If !WinActive(this.Hwnd)
            ControlFocus(this.Hwnd)
        ReleasedKeysArr := WindowWrapperClass.Fn_ReleaseModifiers()
        ControlSend(StringControlSendUp,Control?, this.Hwnd)
        WindowWrapperClass.Fn_RepressModifiers(ReleasedKeysArr)
        If isPriorWindowExist {
            If PriorFocusedControl
                ControlFocus(PriorFocusedControl)
            If !WinActive(PriorActiveWindow)
                WinActivate(PriorActiveWindow)
        }
    }
    Fn_isWindowThisSize(x, y, w, h){
        this.Fn_SetMinMaxState(0)
        WinGetPos(&wx, &wy, &ww, &wh, this.Hwnd)
        Return(x=wx & y=wy & w=ww & h=wh)
    }
    Fn_SetMinMaxState(State){
        Switch State {
            Case -1: (!(this.isMinimized) && WinMinimize(this.Hwnd))
            Case 0: (!(this.isNotMinMax) && WinRestore(this.Hwnd))
            Case 1: (!(this.isMaximized) && WinMaximize(this.Hwnd))
        }
    }
    Fn_SetAbove(WinTitle?){
        If !isSet(WinTitle){
            PriorState := this.isAlwaysOnTop
            this.isAlwaysOnTop := true
            this.isAlwaysOnTop := PriorState
        }
        Else {
            WinTitle := WinGetID(WinTitle)
            TargetIndex := WindowWrapperClass.Fn_GetWindowStackPosition(WinTitle)
            ThisIndex := WindowWrapperClass.Fn_GetWindowStackPosition(this.Hwnd)
            If TargetIndex - ThisIndex = -1 ; if TargetIndex is 1 layer above this.Hwnd ...
                Return
            WindowListArr:=WinGetList()
            Loop WindowListArr.Length {
                CurrentHWND := WindowListArr[-A_Index]
                If (A_Index < TargetIndex) or (CurrentHWND = this.Hwnd)
                    continue
                WindowWrapperClass.Fn_SetAbove(CurrentHWND)
                If (A_Index = TargetIndex)
                    this.Fn_SetAbove()
            }
        }
    }
    Fn_isAbove(WinTitle){
        WinTitleIndex := WindowWrapperClass.Fn_GetWindowStackPosition(WinTitle)
        ThisIndex := WindowWrapperClass.Fn_GetWindowStackPosition(this.Hwnd)
        Return (WinTitleIndex < ThisIndex)
    }
    Fn_SetBelow(WinTitle){
        If !isSet(WinTitle){
            WinMoveBottom(this.Hwnd)
        }
        Else {
            WinTitle := WinGetID(WinTitle)
            TargetIndex := WindowWrapperClass.Fn_GetWindowStackPosition(WinTitle)
            ThisIndex := WindowWrapperClass.Fn_GetWindowStackPosition(this.Hwnd)
            If TargetIndex - ThisIndex = 1 ; if TargetIndex is 1 layer above this.Hwnd ...
                Return
            WindowListArr:=WinGetList()
            Loop WindowListArr.Length {
                CurrentHWND := WindowListArr[-A_Index]
                If (A_Index < TargetIndex) or (CurrentHWND = this.Hwnd)
                    continue
                If (A_Index = TargetIndex)
                        this.Fn_SetAbove()
                WindowWrapperClass.Fn_SetAbove(CurrentHWND)
            }
        }
    }
    Fn_WinMove(x?, y?, w?, h?){
        this.Fn_SetMinMaxState(0)
        If !this.CheckisWindowSize(x, y, w, h)
            WinMove(x?, y?, w?, h?, this.Hwnd)
    }
    Fn_BatchOptions(ObjectWithPropValues){
        For PropName, Value in ObjectWithPropValues.HasOwnProp()
            this.%PropName% := Value
    }
    Static Fn_Range(Value, Min, Max){
        Return (Min < Value and Value < Max)
    }
    Static Fn_ReleaseModifiers(){
        ReleasedKeysArr := []
        Keys := "LAlt|LCtrl|LWin|LShift|RAlt|RCtrl|RWin|RShift"
        For Index, KeyName in StrSplit(Keys, "|"){
            If GetKeyState(KeyName){
                ReleasedKeysArr.Push(KeyName)
                SendEvent "{Blind}{" KeyName " Up}" 
            }
        }
        Return ReleasedKeysArr
    }

    Static Fn_RepressModifiers(ReleasedKeysArr){
        For Index, KeyName in ReleasedKeysArr{
            SendEvent "{Blind}{" KeyName " Down}"
        }
    }

    Static Fn_SetAbove(WinTitle){
        If PriorState := (WinGetExStyle(WinTitle) & 0x8 ? True : False)
            Return
        WinSetAlwaysOnTop(True, WinTitle)
        WinSetAlwaysOnTop(false, WinTitle)
    }

    Static Fn_GetWindowStackPosition(WinTitle){
        WinListArr := WinGetList()
        Loop WinListArr.Length {
            CurrentHwnd := WinListArr[-A_Index]
            if CurrentHwnd = WinGetID(WinTitle){
                Return A_Index
            }
        }
    }
}
